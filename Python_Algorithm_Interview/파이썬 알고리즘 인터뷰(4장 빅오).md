# 파이썬 알고리즘 인터뷰

### Chapter 4 빅오, 자료형

-------------------------------------------------



#### 빅오

빅오(O, big-O)란 입력값이 무한대로 향할때 함수의 상한을 설명하는 수학적 표기 방법이다.

* 상한 : 빅오
* 하한: 빅오메가
* 평균: 빅세타

먼저, 빅오는 점근적 실행시간(Asymptotic Running Time)를 표기할 때 가장 널리 쓰이는 수학적 표기법 중 하나다. 점근적 실행 시간이란 입력값 n이 커질 때, 즉 입력값이 무한대를 향할 때 함수의 실행 시간의 추이를 의미한다.

점근적 실행 시간은 달리 말하면 시간 복잡도라 할 수 있다. 시간복잡도(Time Complexity)의 사전적 정의는 어떤 알고리즘을 수행하는 데 걸리는 시간을 설명하는 계산 복잡도를 의미하며, 계산 복잡도를 표기하는 대표적인 방법이 바로 빅오다. 빅오로 시간 복잡도를 표현할 때는 최고차항만을 표기하며, 상수항은 무시한다.



* O(1) : 입력값이 아무리 커도 실행 시간은 일정하다. 최고의 알고리즘이라 할 수 있고, O(1)에 실행되는 알고리즘으로 ==해시 테이블의 조회 및 삽입==이 이에 해당한다.



* O(log n): 여기서부터 실행 시간은 입력값에 영향을 받는다. 그러나 로그는 매우 큰 입력값에도 크게 영향을 받지 않는 편으로 웬만한 n 의 크기에 대해서도 매우 견고하다. 대표적으로 ==이진 검색==이 이에 해당한다.



* O(n): 입력값만큼 실행 시간에 영향을 받으며, 알고리즘을 수행하는데 걸리는 시간은 입력값에 비례한다. 이러한 알고리즘을 선형 시간(Linear Time) 알고리즘이라고 한다. ==정렬되지 않은 리스트에서 최댓값 또는 최솟값== 경우가 이에 해당하며 이 값을 찾기 위해서는 모든 입력값을 적어도 한 번 이상은 살펴봐야 한다.



* O(n log n): 병합 정렬을 비롯한 대부분의 효율 좋은 정렬 알고리즘이 이에 해당한다.



* O(n^2): 버블 정렬 같은 비효율적인 정렬 알고리즘이 이에 해당한다.



* O(2^n): 피보나치 수를 재귀로 계산하는 알고리즘이 이에 해당한다. 간혹 n^2과 혼동하는 경우가 있는데 처음에는 비슷해 보이지만 2^n이 훨씬 더 크다.



* O(n!): 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 외판원 문제(Travelling Salesman Problem .aka TSP)를 브루트 포스로 풀이할 때가 이에 해당한다. 가장 느린 알고리즘으로 입력 값이 조금만 커져도 웬만한 다항시간 내에는 계산이 어렵다.





빅오는 시간 복잡도 외에도 공간 복잡도를 표현하는 데에도 널리 쓰인다. 또한 알고리즘은 흔히 '시간과 공간이 트레이드오프' 관계다. 이 말은 실행 시간이 빠른 알고리즘은 공간을 많이 사용하고, 공간을 적게 차지하는 알고리즘은 실행시간이 느리다는 얘기다.



#### 분할 상환 분석

시간 또는 메모리를 분석하는 알고리즘의 복잡도를 계산할 때, 알고리즘 전체를 보지 않고 최악의 경우만을 살펴보는 것은 지나치게 비관적이라는 이유로 분할 상환 분석 방법이 등장하는 계기가 됐다.



#### 숫자

파이썬에서는 숫자 정수형으로 `int`만을 제공한다. 그렇다면 `int`보다 더 큰 값은 어떤 자료형에 보관할까? 파이썬에는 `long`이 없을까? `PEP 237`을 통해 버전 2.4부터는 int 가 충분하지 않으면 자동으로 long 타입으로 변경되는 구조가 됐으며 덕분에 오버플로우(overflow)가 발생하는 일이 사라졌다. 따라서 파이썬은 int 단일형으로 통합되었다.



#### 객체

파이썬은 모든 것이 객체다. 이 중에서 크게 불변 객체(Immutable Object)와 가변 객체(Mutable Object)로 구분할 수 있다.

| 클래스 |                             설명                             | 불변 객체 |
| :----: | :----------------------------------------------------------: | :-------: |
|  bool  |                        True or False                         |     O     |
|  int   |                             정수                             |     O     |
| float  |                             실수                             |     O     |
|  list  |                            리스트                            |     X     |
| tuple  | 리스트와 튜플의 차이는 불변 여부이며 이외에는 거의 동일<br /> 튜플은 불편이므로 생성할 때 설정한 값은 변경할 수 없다. |     O     |
|  str   |                             문자                             |     O     |
|  set   |              중복된 값을 갖지 않는 집합 자료형               |     X     |
|  dict  |                           딕셔너리                           |     X     |

tuple은 한번 값을 담아두면 더 이상 값을 변경할 수 없다. 상수처럼 read-only 용도로 사용하거나 무엇보다 값이 변하지 않기 때문에 dict의 키나 set의 값으로도 사용할 수 있다. <u>list는 언제든 값이 변할 수 있기 때문에 dict의 키로 정하거나 set의 값으로는 추가할 수 없다.</u>



#### is 와 ==

파이썬의 비교 연산자 중 `is` 와 `==` 가 있다. 이 둘의 관계는 파이썬의 객체 구조와 관련이 깊다. 먼저,  ==is는 id( ) 값을 비교하는 함수다.== None은 널(null)로서 값 자체가 정의되어 있지 않으므로 `==`로 비교가 불가능하다. 따라서 다음과 같이 `is`로만 비교가 가능하다.

```python
if a is None:
    pass
```

`==`는 잘 알다시피 비교연산자다. 다음과 같이 리스트를 생성해서 비교해보면 `==`와 `is`의 차이에 대해서 금방 이해가 될 것이다.

```python
>>> a = [1,2,3]
>>> a == a
True
>>>
>>> a == list(a)
True
>>>
>>> a is a
True
>>>
>>> a is list(a)
False
```

값은 동일하지만 `list()`로 한 번 더 묶어주면, 별도의 객체로 복사가 되고 다른 id를 갖게 된다. 따라서 `is`는 `False`가 된다.