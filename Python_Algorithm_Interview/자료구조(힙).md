# 자료구조

### 힙(heap)이란

> 힙이란 우선순위 큐를 위하여 만들어진 자료구조



### [Before]

* 우선순위 큐 : 우선순위의 개념을 큐에 도입한 자료구조

  * 데이터들이 우선순위를 가지고 있고 우선순위가 높은 데이터가 먼저 나간다.

    |          자료 구조          |          삭제되는 요소           |
    | :-------------------------: | :------------------------------: |
    |         스택(stack)         | 가장 최근에 들어온 데이터 (LIFO) |
    |          큐(Queue)          |  가장 먼저 들어온 데이터 (FIFO)  |
    | 우선순위 큐(Priority Queue) |   가장 우선순위가 높은 데이터    |

  * 우선순위 큐의 이용 사례

    * 시뮬레이션 시스템
    * 네트워크 트래픽 제어
    * 운영 체제에서의 작업 스케줄링
    * 수치 해석적인 계산

  * 우선순위의 큐는 배열, 연결리스트, 힙으로 구현이 가능하다. 이 중 힙(heap)으로 구현하는 것이 가장 효율적이다.



### 자료구조 '힙(heap)' 이란?

* 완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조이다.
* 여러 개의 값들 중에서 최댓값이나 최솟값을 빠르게 찾아내도록 만들어진 자료구조이다.
* 힙은 일종의 반정렬 상태( 느슨한 정렬 상태 )를 유지한다.
  * 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다는 정도
  * 간단히 말하면 부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은) 이진 트리를 말한다.

* 힙 트리에서는 중복된 값을 허용한다. (이진 탐색 트리에서는 중복된 값을 허용하지 않는다.)



### 힙(heap)의 종류

* 최대 힙 (max heap)
  * 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리
  * key(부모노드) > = key(자식노드)
* 최소 힙(min_heap)
  * 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리
  * key(부모노드) <= key(자식 노드)
* ![image-20200902183912045](C:\Users\이재상\AppData\Roaming\Typora\typora-user-images\image-20200902183912045.png)





### 힙(heap)의 구현

* 힙을 저장하는 표준적인 자료구조는 배열이다.
* 구현을 쉽게 하기 위하여 배열의 첫 번째 인덱스인 0은 사용되지 않는다.
* 특정 위치의 노드 번호는 새로운 노드가 추가되어도 변하지 않는다.
  * 예를 들어 root노드의 오른쪽 노드의 번호는 항상 3이다.
* 힙에서의 부모 노드와 자식 노드의 관계
  * 왼쪽 자식의 인덱스 = (부모의 인덱스) * 2
  * 오른쪽 자식의 인덱스 = (부모의 인덱스) * 2+1
  * 부모의 인덱스 = (자식의 인덱스) / 2





### 힙(heap)의 삽입

1. 힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 이어서 삽입한다.
2. 새로운 노드를 부모 노드들과 교환해서 힙의 성질을 만족시킨다.



### 힙(heap)의 삭제

1. 최대 힙에서 최댓값은 루트 노드이므로 루트 노드가 삭제된다.
   * 최대 힙(max_heap)에서 삭제 연산은 최댓값을 가진 요소를 삭제하는 것이다.
2. 삭제된 루트 노드에는 힙의 마지막 노드를 가져온다.
3. 힙을 재구성한다.



### Python heapq 모듈 사용법

파이썬 heapq 모듈은 이진트리( binary tree ) 기반의 최소 힙(min heap) 자료구조를 제공한다. 자바에 익숙한 사람이라면 `PriorityQueue` 클래스를 생각하면 이해가 쉽다.

`min heap`을 사용하면 원소들이 항상 정렬된 상태로 추가되고 삭제되며, `min heap`에서 가장 작은 값은 언제나 인덱스 0, 즉, 이진트리의 루트에 위치한다. 내부적으로 `min heap` 내의 모든 원소 (k)는 항상 자식 원소들 (2k+1, 2k+2)보다 크기가 작거나 같도록 원소가 추가되고 삭제된다.



#### 최소 힙 생성

`heapq` 모듈에는 파이썬의 보통 리스트를 마치 최소 힙처럼 다룰 수 있도록 도와준다. 그렇기 때문에 그냥 빈 리스트를 생성해 놓은 다음 `heapq` 모듈의 함수를 호출할 때 마다 이 리스트를 인자로 넘겨야 한다.  다시말해 파이썬에서는 `heapq` 모듈을 통해서 원소를 추가하거나 삭제한 리스트가 그냥 최소 힙이다.

```python
heap = []
```



#### 힙에 원소 추가

`heapq` 모듈의 `heappush()` 함수를 이용하여 힙에 원소를 추가할 수 있다. 첫 번째 인자는 원소를 추가할 <u>대상 리스트</u>이며, 두 번째 인자는 <u>추가할 원소</u>를 넘긴다.

```python
heapq.heappush(heap,4)
heapq.heappush(heap,1)
heapq.heappush(heap,7)
heapq.heappush(heap,3)
print(heap)
```

```python
[1,3,7,4]
```

가장 작은 숫자 1이 인덱스 '0'에 위치하며, 인덱스 '1'에 위치한 숫자3은 인덱스'3'에 위치한 숫자 4 보다 크므로 힙의 공식을 만족한다. 내부적으로 이진 트리에 원소를 추가하는 `heappush()` 함수는 O(logN)의 복잡도를 가진다.



#### 힙에서 원소 삭제

`heapq` 모듈의 `heappop()` 함수를 이용하여 힙에서 원소를 삭제할 수 있다. ==원소를 삭제할 대상 리스트를 인자로 넘기면, 가장 작은 원소를 삭제 후에 그 값을 리턴한다.==

```python
print(heapq.heappop(heap))
print(heap)
```

```python
1
[3,4,7]
```

가장 작았던 숫자 1이 삭제되어 리턴되었고, 그 다음으로 작았던 숫자 3이 인덱스 0으로 올라왔다. 내부적으로 이진 트리로부터 원소를 삭제하는 `heappop()` 함수도 역시 O(log N)의 시간 복잡도를 가진다.



#### 최소값 삭제하지 않고 얻기

힙에서 최소값을 삭제하지 않고 단순히 읽기만 하려면 일반적으로 리스트의 첫 번째 원소에 접근하듯이 인덱스를 통해 접근하면 된다.

여기서 주의사항은 인덱스 '0'에 가장 작은 원소가 있다고 해서, 인덱스 '1'에 두 번째 작은 원소, 인덱스'2'에 세 번째 작은 원소가 있다는 보장은 없다. 왜냐하면 힙은 `heappop()` 함수를 호출하여 원소를 삭제할 때 마다 이진 트리의 재배치를 통해 매번 새로운 최소값을 인덱스 '0'에 위치시키기 때문이다.

따라서 두 번째로 작은 원소를 얻으려면 바로 `heap[1]`으로 접근하는 것이 아니라, 반드시 `heappop()`을 통해 가장 작은 원소를 삭제 후에 `heap[0]`를 통해 새로운 최소값에 접근해야 한다.



#### 기존 리스트를 힙으로 변환

이미 원소가 들어있는 리스트를 힙으로 만들려면 `heapq` 모듈의 `heapify()`라는 함수를 사용하면 된다.

```python
heap = [4,1,7,3,8,5]
heapq.heapify(heap)
print(heap)
```

```python
[1,3,5,4,8,7]
```

`heapify()` 함수에 리스트를 인자로 넘기면 리스트 내부의 우너스들의 위에서 다룬 힙 구조에 맞게 재배치되며 최소값이 0번째 인덱스에 위치된다. 즉, 비어있는 리스트를 생성한 후 `heappush()` 함수로 원소를 하나씩 추가한 효과가 난다. `heapify()` 함수의 성능은 인자로 넘기는 리스트의 원소수에 비례한다. 즉 O(N)의 시간 복잡도를 가진다.



#### [응용] 최대 힙

`heapq` 모듈은 최소 힙( min heap )을 기능만으로 동작하기 때문에 최대 힙( max heap )으로 활용하려면 약간의 요령이 필요하다. 바로 힙에 튜플(tuple)을 원소로 추가하거나 삭제하면 튜플 내에서 맨 앞에 있는 값을 기준으로 최소 힙이 구성되는 원리를 이용하는 것이다.

따라서, 최대 힙을 만들려면 각 값에 대한 우선 순위를 구한 후, ( 우선 순위, 값 ) 구조의 튜블( tuple )을 힙에 추가하거나 삭제하면 된다. 그리고 힙에 추가하거나 삭제하면 된다. 그리고 힙에서 값을 읽어올 때는 각 튜플에서 인덱스 '1'에 있는 값을 취하면 된다.

```python
import heapq

nums = [4,1,7,3,8,5]
heap = []

for num in nums:
    heapq.heappush(heap, (-num, num))
    
while heap:
    print(heapq.heappop(heap)[1])
```

```python
8
7
5
4
3
1
```



#### [응용] K번째 최소값/ 최대값

최소 힙이나 최대 힙을 사용하면 K번째 최소값이나 최대 값을 효율적으로 구할 수 있다.

```python
import heapq

def kth_smallest(num, k):
    heap = []
    for num in nums:
        heapq.heappush(heap, num)
        
    kth_min = None
    for _ in range(k):
        kth_min = heapq.heappop(heap)
    return k_min

print(kth_smallest([4,1,7,3,8,5],3))
```

```python
4
```

K번째 최소 값을 구하기 위해서는 주어진 배열로 힙을 만든 후, `heappop()` 함수를 K번 호출하면 된다.



#### 힙 정렬

힙 정렬 (heap sort)은 위에서 설명드린 힙 자료구조의 성질을 이용한 대표적인 정렬 알고리즘이다.

```python
import heapq

def heap_sort(nums):
    heap = []
    for num in nums:
        heapq.heappush(heap, num)
        
    sorted_num = []
    while heap:
        sorted_num.append(heapq.heappop(heap))
    return sorted_num

print(heap_sort[4,1,7,3,8,5])
```

```python
[1,3,4,5,7,8]
```

