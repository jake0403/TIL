# 파이썬 알고리즘 인터뷰

### Chapter 5 리스트, 딕셔너리

------------------------------------------------------



#### 리스트

리스트에 여러개 값 추가하기 => `.extend()`

```python
>>> x = [1,2,3,4,5]
>>> x.extend([6,7,8,9])
>>> x
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

지정된 인덱스에 리스트 값 추가하기 => `.insert()`

```python
>>> x = [1,2,3,4,5]
>>> x.insert(2,2.5)
>>> x
[1, 2, 2.5, 3, 4, 5]
```



리스트에서 요소를 삭제하는 방법은 크게 2가지가 있다.

* 인덱스로 삭제하기 => del 리스트 변수명[인덱스]
* 값으로 삭제하기 => 리스트 변수명.remove(삭제하고자 하는 값)

```python
# del 함수를 사용해 index 값 지정 삭제  ====> 인덱스를 사용한 추가는 insert(인덱스 값, 추가할 값) ===> pop(인덱스) 또한 마찬가지임.
>>> a = [1,2,3,4,5]
>>> a
[1, 2, 3, 4, 5]
>>> del a[1]
>>> a
[1, 3, 4, 5]
```

```python
# remove() 함수 사용해 특정 값 삭제
>>> a
[1, 2, 3, 4, 5]
>>> a.remove(2)
>>> a
[1, 3, 4, 5]
```



#### 딕셔너리

파이썬의 딕셔너리는 Key/Value 구조로 이뤄진 딕셔너리를 말한다. 입력 순서가 유지되며, 내부적으로는 해시 테이블(Hash Table)로 구현되어 있다.

인덱스를 숫자로만 지정할 수 있는 리스트와 달리 딕셔너리는 문자를 포함해 다양한 타입을 키로 사용할 수 있다.

원래 파이썬에서 딕셔너리는 입력 순서가 유지되지 않았다. 마찬가지로 대부분의 언어에서 해시 테이블을 이용한 자료형은 입력 순서가 유지되지 않는다. 파이썬도 3.6 이하에서는 입력 순서가 유지되지 않아 `collections.OrderedDict()`라는 별도 자료형을 제공했다. 그러나 파이썬 3.7부터는 내부적으로 인덱스를 이용해 입력 순서를 유지하도록 개선됐다.

다만, 여전히 3.6이하 버전을 사용하는 곳이 많고, 하위 버전과의 호환성, 코딩 데스트 시에도 인터프리터의 버전을 정확히 확인할 수 없는 상황에서는 입력 순서가 유지되지 않을 수 있으므로, 딕셔너리dy의 입력 순서가 유지될 것이라고 가정하고 진행하는 것은 매우 위험하며 일반적으로 권장하지 않는다. 이외에도 파이썬 3.6부터는 딕셔너리의 메모리 사용량이 20% 정도 줄어드는 성능 개선 또한 진행됐다.

* 파이썬 3.7+ : 딕셔너리 입력 순서 유지
* 파이썬 3.6+ : 딕셔너리 메모리 사용량 20% 감소

이러한 개선 외에도 파이썬에서는 딕셔너리를 효율적으로 생성하기 위한 추가 모듈을 많이 지원한다. 파이썬 3.6 이하에서 항상 입력 순서가 유지되는 `collections.OrderedDict()`를 비롯해

* 조회 시 항상 디폴트 값을 생성해 키 오류를 방지하는 `collections.defaultdict()`
* 요소의 값을 키로 하고 개수를 값 형태로 만들어 카운팅하는 `collections.Counter()` 등이 있다.

딕셔너리에 있는 키/값은 `for` 반복문으로도 조회가 가능하다. 다음과 같이 딕셔너리의 `items()` 메소드를 사용하면 키와 값을 각각 꺼내올 수 있다.

```python
>>> a
{'b': 2, 'c': 3, 'd': 4}
>>> for i,j in a.items():
...     print(i,j)
...
b 2
c 3
d 4
```

딕셔너리의 키는 앞서 에러가 발생하는 부분에서 잠깐 살펴봤던 것 처럼 다음과 같이 `del 딕셔너리명[key값]`로 삭제한다.

```python
>>> a
{'b': 2, 'c': 3, 'd': 4}
>>> del a['b']
>>> a
{'c': 3, 'd': 4}
```



#### 딕셔너리 모듈

딕셔너리와 관련된 특수한 형태의 컨테이너 자료형

* `defaultdict`
* `Counter`
* `OrderedDict`

##### defaultdict 객체

`defaultdict`객체는 존재하지 않는 키를 조회할 경우, 에러 메시지를 출력하는 대신 디폴트 값을 기준으로 해당 키에 대한 딕셔너리 아이템을 생성해준다. 마찬가지로 실제로는 `collections.defaultdict` 클래스를 갖는다.

```python
>>> from collections import defaultdict
>>> a = defaultdict(int)
>>> a['A'] = 5
>>> a['B'] = 4
>>> a
defaultdict(<class 'int'>, {'A': 5, 'B': 4})
```

여기서 A와 B에 5와 4를 할당했다. a 딕셔너리에는 이렇게 2개의 아이템이 존재한다.

```python
>>> a['C']+=1
>>> a
defaultdict(<class 'int'>, {'A': 5, 'B': 4, 'C': 1})
```

이제 C는 존재하지 않는 키다. 원래의 딕셔너리라면 `KeyError`가 발생하겠지만, `defaultdict` 객체는 에러 없이 바로 +1 연산이가능하고 이 경우 디폴트인 0을 기준으로 자동으로 생성한 후 여기에 1을 더해 최종적으로 1이 만들어진다.



##### Counter 객체

Counter 객체는 아이템에 대한 개수를 계산해 딕셔너리로 리턴하며, 다음과 같이 사용한다.

```python
>>> import collections
>>> a = [1,2,3,4,5,5,5,6,6]
>>> b = collections.Counter(a)
>>> b
Counter({5: 3, 6: 2, 1: 1, 2: 1, 3: 1, 4: 1})
```

Counter 객체는 이처럼 키에는 아이템의 값이, 값에는 해당 아이템의 개수가 들어간 딕셔너리를 생성한다. 실제로는 다음과 같이 딕셔너리를 한 번 더 래핑(Wrapping)한 `collections.Counter` 클래스를 갖는다.

개수를 자동으로 계산해주기 때문에 매우 편리하며, 여러 분야에서 다양하게 활용된다. 그렇다면 Counter 객체에서 가장 빈도 수가 높은 요소는 어떻게 추출할 수 있을까? 다음과 같이 `most_common()`을 사용하면 된다.

```python
>>> b.most_common(2)
[(5, 3), (6, 2)]
```



#### OrderedDict 객체

대부분의 언어에서 해시 테이블을 이용한 자료형은 입력 순서가 유지되지 않는다. 파이썬 3.6 이하에서는 마찬가지였고 입력 순서가 유지되는 `OrderedDict`는 입력 그대로 순서가 유지된다.

```python
>>> a = [1,2,3,4,5,5,5,6,6]
>>> b = collections.Counter(a)
>>> b
Counter({5: 3, 6: 2, 1: 1, 2: 1, 3: 1, 4: 1})		# 입력 순서 유지(X)
>>> c = collections.OrderedDict(b)
>>> c
OrderedDict([(1, 1), (2, 1), (3, 1), (4, 1), (5, 3), (6, 2)])	# 입력 순서 유지(O)
```

